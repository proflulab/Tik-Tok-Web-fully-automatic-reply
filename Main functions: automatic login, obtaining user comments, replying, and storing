from selenium import webdriver
import time
import pickle
import threading
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

import json
from urllib import request, error
import threading

import pandas as pd
import os

data_list = []  # 这里定义一个全局变量来存储数据


def create_chrome_driver():  # 打开浏览器
    options = Options()
    options.add_argument("--start-maximized")  # 启动时最大化窗口
    return webdriver.Chrome(options=options)  # 默认使用chromedriver的系统路径


chrome = create_chrome_driver()


def send_message(message):  # 向抖音直播间发送信息
    """发送指定的消息并按下 Enter 键"""
    try:
        # 等待文本区域元素加载并找到
        text_element = WebDriverWait(chrome, 10).until(
            EC.presence_of_element_located((By.XPATH, '//textarea[@class="webcast-chatroom___textarea"]'))
        )
        text_element.clear()
        text_element.send_keys(message)
        time.sleep(0.5)

        # 按下 Enter 键发送消息
        text_element.send_keys(Keys.RETURN)
    except Exception as e:
        print(f"发送消息时发生错误: {e}")


def monitor_screen():  # 获取用户在抖音直播间发送的信息
    last_data_id = None  # 用于存储上一个 `data-id`

    try:
        while True:
            try:
                # 确保页面元素加载完成
                web_text_elements = WebDriverWait(chrome, 10).until(
                    EC.presence_of_all_elements_located(
                        (By.CSS_SELECTOR, 'div.webcast-chatroom___item.webcast-chatroom___enter-done'))
                )

                if web_text_elements:
                    # 提取最新的元素
                    latest_element = web_text_elements[-1]

                    # 获取当前元素的 `data-id`
                    current_data_id = latest_element.get_attribute('data-id')

                    # 如果 `data-id` 与上一个相同，则跳过
                    if current_data_id == last_data_id:
                        time.sleep(0.2)  # 等待一段时间后再次检查
                        continue

                    # 更新 `last_data_id`
                    last_data_id = current_data_id

                    try:
                        # 尝试获取用户名
                        username_element = latest_element.find_element(By.CSS_SELECTOR, '.u2QdU6ht')
                        username = username_element.text.split('：')[0]  # 去掉用户名中的 `：`

                        # 尝试获取评论
                        comment_element = latest_element.find_element(By.CSS_SELECTOR, '.WsJsvMP9')
                        comment = comment_element.text

                        # 将新数据作为新行添加到 data_list 中
                        data_list.append([username, comment])

                        # 打印用户名和评论
                        # print(f"用户名: {username} | 评论: {comment}")
                    except Exception as inner_e:
                        # 如果在尝试获取用户名或评论时出错，继续到下一个元素
                        print("## 提取信息时发生错误，可能是没找到类别，不用在意，可以查看这段代码的位置进行调试 ##")  # 防止一些非信息元素出bug
                        inner_e = inner_e  # 这段变量没有任何用处，只是防止报错，如果要调试，可以删除这段代码
                        # print(f"提取信息时发生错误: {inner_e}")  # 调试使用
                        continue

                else:
                    print("没有找到发言元素")

            except Exception as e:
                print(f"监控公屏时发生错误: {e}")

            # 等待一段时间后再次检查
            time.sleep(2)  # 可以根据需要调整检查间隔

    except Exception as e:
        print(f"监控公屏时发生错误: {e}")


def main_req(user_text, bot_id):  # 向coze机器人客服发送信息
    url = "https://api.coze.cn/open_api/v2/chat"
    headers = {
        "Authorization": "你的coze_bot_token",
        "Content-Type": "application/json",
        "Accept": "*/*",
        "Connection": "keep-alive"
    }

    data = {
        "conversation_id": "123",
        "bot_id": bot_id,
        "user": "29032201862555",
        "query": user_text,
        "stream": False
    }

    # Convert data to JSON string and encode it
    data = json.dumps(data).encode()

    # Create a Request object
    req = request.Request(url, data=data, headers=headers, method='POST')

    try:
        # Send the request and get the response
        with request.urlopen(req) as response:
            response_data = response.read()
            # Decode JSON response
            response_json = json.loads(response_data.decode())

            # 遍历消息列表，找到第一个类型为 'answer' 的消息
            for message in response_json.get('messages', []):
                if message.get('type') == 'answer':
                    # 返回该消息的内容
                    return message.get('content', '内容为空').strip()  # 删除首尾空格

    except error.HTTPError as e:
        print(f"HTTP Error: {e.code} - {e.reason}")
        response_body = e.read()
        print(f"Response body: {response_body.decode()}")
    except error.URLError as e:
        print(f"URL Error: {e.reason}")
    except Exception as e:
        print(f"Unexpected error: {e}")

    return '请求失败'  # 请求失败时的返回内容


def run_main_thread():  # 主运行部分
    data_list_round_count = 0  # 这是运行到的行数值

    try:
        while True:
            if data_list:
                # 如果 data_list 不是空的，处理数据

                if len(data_list) > data_list_round_count:
                    # 调用用户综合数据，user_typ_complex是发送给coze机器人的，username是用户姓名，comment是用户评论
                    user_typ_complex, username, comment = user_typ_transfer(data_list_round_count)
                    user_typ = user_typ_complex  # 获取用户输入
                    print(user_typ)
                    result = main_req(user_typ, "你的客服id")  # 获取机器人回复
                    # 提取 result 的前面三个字符
                    first_three_chars = result[:3]
                    print(first_three_chars)

                    # 检查 result 是否不等于 "非问句"
                    if first_three_chars == "是问句":
                        remaining_chars = result[3:]  # 出去前面三个字来判断问句，回复储存到变量里面

                        # 发送信息到抖音
                        # send_message(remaining_chars)

                        # 将用户信息以及机器人回复储存到Excel
                        append_to_excel('data.xlsx', username, comment, remaining_chars)
                        print(remaining_chars)

                    data_list_round_count += 1

            else:
                # 如果 data_list 为空，可以选择暂停一段时间再检查
                time.sleep(1)  # 暂停 1 秒

    except KeyboardInterrupt:
        print("程序被中断")


def user_typ_transfer(data_list_round_count):  # 获取并且转换列表内的信息
    # 检查 data_list 是否为空
    if not data_list:
        return "数据列表为空"

    # 访问第一行的资料
    data_row = data_list[data_list_round_count]
    username = data_row[0]  # 用户名字
    comment = data_row[1]  # 用户发送的信息

    # 这部分代码是综合起来发送给机器人的
    user_typ_complex = f"用户名: {username} | 评论: {comment}"

    # 返回格式化的字符串
    return user_typ_complex, username, comment


def append_to_excel(file_path, username, user_comment, bot_reply):  # 储存信息到Excel
    # file_path是文件名称，username是抖音用户名称，user_comment是用户评论，bot_reply是机器人回复

    # 检查文件是否存在
    if os.path.exists(file_path):
        # 如果文件存在，从 Excel 中加载数据
        df = pd.read_excel(file_path, engine='openpyxl')
    else:
        # 如果文件不存在，创建一个新的 DataFrame
        df = pd.DataFrame(columns=['用户名', '用户评论', '客服回复'])

    # 新数据
    new_data = {
        '用户名': [username],
        '用户评论': [user_comment],
        '客服回复': [bot_reply]
    }

    # 将新数据转换为 DataFrame
    new_df = pd.DataFrame(new_data)

    # 将新数据追加到 DataFrame
    df = pd.concat([df, new_df], ignore_index=True)

    # 将 DataFrame 保存到 Excel 文件
    df.to_excel(file_path, index=False, engine='openpyxl')


def main():  # 启动双线程
    # 启动线程
    thread1 = threading.Thread(target=monitor_screen, name="MonitorScreen")
    thread2 = threading.Thread(target=run_main_thread, name="MainThread")

    global data_list  # 用于处理用户回复
    data_list = []  # 清空数据列表

    thread1.start()
    thread2.start()


if __name__ == '__main__':
    # 加载之前保存的Cookie
    with open("douyin_cookie.pickle", 'rb') as file:
        cookies_list = pickle.load(file)

    # 创建Chrome浏览器实例
    chrome = create_chrome_driver()

    # 打开抖音网站
    chrome.get('https://www.douyin.com/')

    # 添加Cookie以实现持久登录
    for cookie in cookies_list:
        chrome.add_cookie(cookie)

    # 自定义您要进入的直播间链接
    chrome.get('https://live.douyin.com/741682777632')

    # 等待一段时间，确保页面加载完毕
    time.sleep(10)

    # 启动主程序
    main()
